(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{1384:function(e,t,i){"use strict";i.r(t),i.d(t,"initRustCrypto",(function(){return r}));var s=i(1391),n=i(1538);async function r(e,t,i,r,o,a,c,u){var g;await s.initAsync(),new s.Tracing(s.LoggerLevel.Debug).turnOn();const h=new s.UserId(i),d=new s.DeviceId(r);e.info("Init OlmMachine");const l=await s.OlmMachine.initialize(h,d,null!=c?c:void 0,null!==(g=c&&u)&&void 0!==g?g:void 0),p=new n.a(e,l,t,i,r,o,a);return await l.registerRoomKeyUpdatedCallback((e=>p.onRoomKeysUpdated(e))),await l.registerUserIdentityUpdatedCallback((e=>p.onUserIdentityUpdated(e))),p.checkSecrets("m.megolm_backup.v1"),await l.registerReceiveSecretCallback(((e,t)=>p.checkSecrets(e))),await l.outgoingRequests(),e.info("Completed rust crypto-sdk setup"),p}},1538:function(e,t,i){"use strict";(function(e){i.d(t,"a",(function(){return P}));var s=i(5),n=i.n(s),r=i(192),o=i.n(r),a=i(1391),c=i(32),u=i(15),g=i(1539),h=i(1540),d=i(1541),l=i(7),p=i(42),y=i(1542),m=i(208),f=i(1543),v=i(1544),w=i(243),k=i(227),S=i(103),b=i(1545),R=i(9),K=i(45),C=i(51),I=i(1546),_=i(169),M=i(76),E=i(186),q=i(71),O=i(251),B=i(1547);function V(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,s)}return i}function D(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?V(Object(i),!0).forEach((function(t){n()(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):V(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}const U=["m.sas.v1","m.qr_code.scan.v1","m.qr_code.show.v1","m.reciprocate.v1"];class P extends C.b{constructor(e,t,i,s,r,o,a){super(),this.logger=e,this.olmMachine=t,this.http=i,this.userId=s,this.secretStorage=o,this.cryptoCallbacks=a,n()(this,"_trustCrossSignedDevices",!0),n()(this,"stopped",!1),n()(this,"roomEncryptors",{}),n()(this,"eventDecryptor",void 0),n()(this,"keyClaimManager",void 0),n()(this,"outgoingRequestProcessor",void 0),n()(this,"crossSigningIdentity",void 0),n()(this,"backupManager",void 0),n()(this,"outgoingRequestsManager",void 0),n()(this,"sessionLastCheckAttemptedTime",{}),n()(this,"reemitter",new _.b(this)),n()(this,"globalBlacklistUnverifiedDevices",!1),n()(this,"_supportedVerificationMethods",U),this.outgoingRequestProcessor=new h.a(t,i),this.outgoingRequestsManager=new B.a(this.logger,t,this.outgoingRequestProcessor),this.keyClaimManager=new d.a(t,this.outgoingRequestProcessor),this.eventDecryptor=new T(this.logger,t,this),this.backupManager=new I.b(t,i,this.outgoingRequestProcessor),this.reemitter.reEmit(this.backupManager,[K.b.KeyBackupStatus,K.b.KeyBackupSessionsRemaining,K.b.KeyBackupFailed]),this.crossSigningIdentity=new f.a(t,this.outgoingRequestProcessor,o),this.checkKeyBackupAndEnable()}startQueryKeyBackupRateLimited(e,t){const i=(new Date).getTime(),s=this.sessionLastCheckAttemptedTime[t];if(!s||i-s>5e3)this.sessionLastCheckAttemptedTime[t]=i,this.queryKeyBackup(e,t).catch((e=>{this.logger.error(`Unhandled error while checking key backup for session ${t}`,e)}));else{const e=new Date(s).toISOString();this.logger.debug(`Not checking key backup for session ${t} (last checked at ${e})`)}}async queryKeyBackup(e,t){const i=await this.olmMachine.getBackupKeys();if(!i.decryptionKey)return void this.logger.debug(`Not checking key backup for session ${t} (no decryption key)`);this.logger.debug(`Checking key backup for session ${t}`);const s=i.backupVersion,n=Object(l.o)("/room_keys/keys/$roomId/$sessionId",{$roomId:e,$sessionId:t});let r;try{r=await this.http.authedRequest(u.i.Get,n,{version:s},void 0,{prefix:u.a.V3})}catch(e){return void this.logger.info(`No luck requesting key backup for session ${t}: ${e}`)}if(this.stopped)return;const o=new I.a(i.decryptionKey),a={[t]:r},c=await o.decryptSessions(a);for(const t of c)t.room_id=e;await this.importRoomKeys(c)}getOlmMachineOrThrow(){if(this.stopped)throw new E.a;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.olmMachine.close())}async encryptEvent(e,t){const i=e.getRoomId(),s=this.roomEncryptors[i];if(!s)throw new Error(`Cannot encrypt event in unconfigured room ${i}`);await s.encryptEvent(e,this.globalBlacklistUnverifiedDevices)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return await this.eventDecryptor.attemptEventDecryption(e)}getEventEncryptionInfo(e){var t;const i={};return i.senderKey=null!==(t=e.getSenderKey())&&void 0!==t?t:void 0,i.algorithm=e.getWireContent().algorithm,i.senderKey&&i.algorithm?(i.encrypted=!0,i.authenticated=!0,i.mismatchedSender=!0,i):(i.encrypted=!1,i)}checkUserTrust(e){return new p.UserVerificationStatus(!1,!1,!1)}getStoredCrossSigningForUser(e){return null}async checkOwnCrossSigningTrust(){}getVersion(){const e=a.getVersions();return`Rust SDK ${e.matrix_sdk_crypto} (${e.git_sha}), Vodozemac ${e.vodozemac}`}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.ensureEncryptionSession(this.globalBlacklistUnverifiedDevices)}forceDiscardSession(e){var t;return null===(t=this.roomEncryptors[e])||void 0===t?void 0:t.forceDiscardSession()}async exportRoomKeys(){const e=await this.olmMachine.exportRoomKeys((()=>!0));return JSON.parse(e)}async importRoomKeys(e,t){const i=JSON.stringify(e);await this.olmMachine.importRoomKeys(i,((e,i)=>{var s;const n={total:Number(i),successes:Number(e),stage:"load_keys",failures:0};null==t||null===(s=t.progressCallback)||void 0===s||s.call(t,n)}))}async userHasCrossSigningKeys(e=this.userId,t=!1){const i=await this.olmMachine.trackedUsers();let s;for(const t of i)if(e===t.toString()){s=t;break}if(void 0!==s){if(e===this.userId){const e=this.olmMachine.queryKeysForUsers([s]);await this.outgoingRequestProcessor.makeOutgoingRequest(e)}return void 0!==await this.olmMachine.getIdentity(s)}if(t){var n;const t=null===(n=(await this.downloadDeviceList(new Set([e]))).master_keys)||void 0===n?void 0:n[e];return!!t&&Boolean(Object.values(t.keys)[0])}return!1}async getUserDeviceInfo(e,t=!1){const i=new Map,s=await this.olmMachine.trackedUsers(),n=new Set;s.forEach((e=>n.add(e.toString())));const r=new Set;for(const t of e)n.has(t)?i.set(t,await this.getUserDevices(t)):r.add(t);if(t&&r.size>=1){const e=await this.downloadDeviceList(r);Object.entries(e.device_keys).forEach((([e,t])=>i.set(e,Object(y.a)(t))))}return i}async getUserDevices(e){const t=new a.UserId(e),i=await this.olmMachine.getUserDevices(t);try{const e=i.devices();try{return new Map(e.map((e=>[e.deviceId.toString(),Object(y.b)(e,t)])))}finally{e.forEach((e=>e.free()))}}finally{i.free()}}async downloadDeviceList(e){const t={device_keys:{}};return e.forEach((e=>t.device_keys[e]=[])),await this.http.authedRequest(u.i.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}async setDeviceVerified(e,t,i=!0){const s=await this.olmMachine.getDevice(new a.UserId(e),new a.DeviceId(t));if(!s)throw new Error(`Unknown device ${e}|${t}`);await s.setLocalTrust(i?a.LocalTrust.Verified:a.LocalTrust.Unset)}async getDeviceVerificationStatus(e,t){const i=await this.olmMachine.getDevice(new a.UserId(e),new a.DeviceId(t));return i?new p.DeviceVerificationStatus({signedByOwner:i.isCrossSignedByOwner(),crossSigningVerified:i.isCrossSigningTrusted(),localVerified:i.isLocallyTrusted(),trustCrossSignedDevices:this._trustCrossSignedDevices}):null}async getUserVerificationStatus(e){const t=await this.olmMachine.getIdentity(new a.UserId(e));return void 0===t?new p.UserVerificationStatus(!1,!1,!1):new p.UserVerificationStatus(t.isVerified(),!1,!1)}async isCrossSigningReady(){const{publicKeysOnDevice:e,privateKeysInSecretStorage:t,privateKeysCachedLocally:i}=await this.getCrossSigningStatus(),s=Boolean(i.masterKey)&&Boolean(i.selfSigningKey)&&Boolean(i.userSigningKey);return e&&(s||t)}async getCrossSigningKeyId(e=p.CrossSigningKey.Master){const t=await this.olmMachine.getIdentity(new a.UserId(this.userId)),i=await this.olmMachine.crossSigningStatus(),s=i.hasMaster&&i.hasUserSigning&&i.hasSelfSigning;if(!t||!s)return null;if(!t.isVerified())return null;let n;switch(e){case p.CrossSigningKey.Master:n=t.masterKey;break;case p.CrossSigningKey.SelfSigning:n=t.selfSigningKey;break;case p.CrossSigningKey.UserSigning:n=t.userSigningKey;break;default:return null}const r=JSON.parse(n);return Object.values(r.keys)[0]}async bootstrapCrossSigning(e){await this.crossSigningIdentity.bootstrapCrossSigning(e)}async isSecretStorageReady(){const e=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];return null!=await this.backupManager.getActiveBackupVersion()&&e.push("m.megolm_backup.v1"),Object(v.a)(this.secretStorage,e)}async bootstrapSecretStorage({createSecretStorageKey:e,setupNewSecretStorage:t,setupNewKeyBackup:i}={}){const s=t||!await this.secretStorageHasAESKey();if(s){if(!e)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");const t=await e();await this.addSecretStorageKeyToSecretStorage(t)}const n=await this.olmMachine.crossSigningStatus();if(n.hasMaster&&n.hasSelfSigning&&n.hasUserSigning&&(s||!await Object(v.b)(this.secretStorage))){const e=await this.olmMachine.exportCrossSigningKeys();if(!e.masterKey)throw new Error("missing master key in cross signing private keys");if(!e.userSigningKey)throw new Error("missing user signing key in cross signing private keys");if(!e.self_signing_key)throw new Error("missing self signing key in cross signing private keys");await this.secretStorage.store("m.cross_signing.master",e.masterKey),await this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey),await this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key),i&&await this.resetKeyBackup()}}async addSecretStorageKeyToSecretStorage(e){var t,i;if(!e.keyInfo)throw new Error("missing keyInfo field in the secret storage key");const s=await this.secretStorage.addKey(m.SECRET_STORAGE_ALGORITHM_V1_AES,e.keyInfo);await this.secretStorage.setDefaultKeyId(s.keyId),null===(t=(i=this.cryptoCallbacks).cacheSecretStorageKey)||void 0===t||t.call(i,s.keyId,s.keyInfo,e.privateKey)}async secretStorageHasAESKey(){const e=await this.secretStorage.getKey();if(!e)return!1;const[,t]=e;return t.algorithm===m.SECRET_STORAGE_ALGORITHM_V1_AES}async getCrossSigningStatus(){const e=await this.getOlmMachineOrThrow().getIdentity(new a.UserId(this.userId)),t=Boolean(null==e?void 0:e.masterKey)&&Boolean(null==e?void 0:e.selfSigningKey)&&Boolean(null==e?void 0:e.userSigningKey),i=await Object(v.b)(this.secretStorage),s=await this.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:i,privateKeysCachedLocally:{masterKey:Boolean(null==s?void 0:s.hasMaster),userSigningKey:Boolean(null==s?void 0:s.hasUserSigning),selfSigningKey:Boolean(null==s?void 0:s.hasSelfSigning)}}}async createRecoveryKeyFromPassphrase(e){let t;const i={};if(e){const s=await Object(w.c)(e);i.passphrase={algorithm:"m.pbkdf2",iterations:s.iterations,salt:s.salt},t=s.key}else t=new Uint8Array(32),S.b.getRandomValues(t);return{keyInfo:i,encodedPrivateKey:Object(k.b)(t),privateKey:t}}async getEncryptionInfoForEvent(e){return this.eventDecryptor.getEncryptionInfoForEvent(e)}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new a.UserId(e)).filter((e=>void 0===e.roomId)).map((e=>new b.a(e,this.outgoingRequestProcessor,this._supportedVerificationMethods)))}findVerificationRequestDMInProgress(e,t){if(!t)throw new Error("missing userId");const i=this.olmMachine.getVerificationRequests(new a.UserId(t)).find((t=>{var i;return(null===(i=t.roomId)||void 0===i?void 0:i.toString())===e}));if(i)return new b.a(i,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async requestVerificationDM(e,t){const i=await this.olmMachine.getIdentity(new a.UserId(e));if(!i)throw new Error(`unknown userId ${e}`);const s=this._supportedVerificationMethods.map((e=>Object(b.c)(e))),n=await i.verificationRequestContent(s),r=await this.sendVerificationRequestContent(t,n),o=await i.requestVerification(new a.RoomId(t),new a.EventId(r),s);return new b.a(o,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async sendVerificationRequestContent(e,t){const i=Object(M.b)(32),{event_id:s}=await this.http.authedRequest(u.i.Put,`/_matrix/client/v3/rooms/${encodeURIComponent(e)}/send/m.room.message/${encodeURIComponent(i)}`,void 0,t,{prefix:""});return s}setSupportedVerificationMethods(e){this._supportedVerificationMethods=null!=e?e:U}async requestOwnUserVerification(){const e=await this.olmMachine.getIdentity(new a.UserId(this.userId));if(void 0===e)throw new Error("cannot request verification for this device when there is no existing cross-signing key");const[t,i]=await e.requestVerification(this._supportedVerificationMethods.map(b.c));return await this.outgoingRequestProcessor.makeOutgoingRequest(i),new b.a(t,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async requestDeviceVerification(e,t){const i=await this.olmMachine.getDevice(new a.UserId(e),new a.DeviceId(t));if(!i)throw new Error("Not a known device");const[s,n]=await i.requestVerification(this._supportedVerificationMethods.map(b.c));return await this.outgoingRequestProcessor.makeOutgoingRequest(n),new b.a(s,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async getSessionBackupPrivateKey(){const t=await this.olmMachine.getBackupKeys();return t.decryptionKey?e.from(t.decryptionKey.toBase64(),"base64"):null}async storeSessionBackupPrivateKey(e,t){const i=Object(q.b)(e);if(!t)throw new Error("storeSessionBackupPrivateKey: version is required");await this.olmMachine.saveBackupDecryptionKey(a.BackupDecryptionKey.fromBase64(i),t)}async getActiveSessionBackupVersion(){return await this.backupManager.getActiveBackupVersion()}async isKeyBackupTrusted(e){return await this.backupManager.isKeyBackupTrusted(e)}async checkKeyBackupAndEnable(){return await this.backupManager.checkKeyBackupAndEnable(!0)}async deleteKeyBackupVersion(e){await this.backupManager.deleteKeyBackupVersion(e)}async resetKeyBackup(){const e=await this.backupManager.setupKeyBackup((e=>this.signObject(e)));await this.secretStorageHasAESKey()&&await this.secretStorage.store("m.megolm_backup.v1",e.decryptionKey.toBase64()),this.checkKeyBackupAndEnable()}async signObject(e){const t=new Map(Object.entries(e.signatures||{})),i=e.unsigned;delete e.signatures,delete e.unsigned;const s=t.get(this.userId)||{},n=o.a.stringify(e),r=await this.olmMachine.sign(n),a=JSON.parse(r.asJSON());t.set(this.userId,D(D({},s),a[this.userId])),void 0!==i&&(e.unsigned=i),e.signatures=Object.fromEntries(t.entries())}async getBackupDecryptor(e,t){if("m.megolm_backup.v1.curve25519-aes-sha2"!=e.algorithm)throw new Error(`getBackupDecryptor Unsupported algorithm ${e.algorithm}`);const i=e.auth_data;if(!(t instanceof Uint8Array))throw new Error("getBackupDecryptor expects Uint8Array");const s=a.BackupDecryptionKey.fromBase64(Object(q.b)(t));if(i.public_key!=s.megolmV1PublicKey.publicKeyBase64)throw new Error("getBackupDecryptor key mismatch error");return new I.a(s)}async receiveSyncChanges({events:e,oneTimeKeysCounts:t=new Map,unusedFallbackKeys:i,devices:s=new a.DeviceLists}){const n=await this.olmMachine.receiveSyncChanges(e?JSON.stringify(e):"[]",s,t,i);return JSON.parse(n)}async preprocessToDeviceMessages(e){const t=await this.receiveSyncChanges({events:e});for(const e of t)e.type===R.b.KeyVerificationRequest&&this.onIncomingKeyVerificationRequest(e.sender,e.content);return t}async processKeyCounts(e,t){const i=e&&new Map(Object.entries(e)),s=t&&new Set(t);void 0===i&&void 0===s||await this.receiveSyncChanges({oneTimeKeysCounts:i,unusedFallbackKeys:s})}async processDeviceLists(e){var t,i;const s=new a.DeviceLists(null===(t=e.changed)||void 0===t?void 0:t.map((e=>new a.UserId(e))),null===(i=e.left)||void 0===i?void 0:i.map((e=>new a.UserId(e))));await this.receiveSyncChanges({devices:s})}async onCryptoEvent(e,t){const i=t.getContent(),s=this.roomEncryptors[e.roomId];s?s.onCryptoEvent(i):this.roomEncryptors[e.roomId]=new g.a(this.olmMachine,this.keyClaimManager,this.outgoingRequestsManager,e,i)}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",e)}))}onIncomingKeyVerificationRequest(e,t){const i=t.transaction_id;if(!i||!e)return;const s=this.olmMachine.getVerificationRequest(new a.UserId(e),i);s&&this.emit(K.b.VerificationRequestReceived,new b.a(s,this.outgoingRequestProcessor,this._supportedVerificationMethods))}onRoomMembership(e,t,i){const s=this.roomEncryptors[e.getRoomId()];s&&s.onRoomMembership(t)}async onRoomKeysUpdated(e){for(const t of e)this.onRoomKeyUpdated(t);this.backupManager.maybeUploadKey()}onRoomKeyUpdated(e){if(this.stopped)return;this.logger.debug(`Got update for session ${e.senderKey.toBase64()}|${e.sessionId} in ${e.roomId.toString()}`);const t=this.eventDecryptor.getEventsPendingRoomKey(e);if(0!==t.length){this.logger.debug("Retrying decryption on events:",t.map((e=>`${e.getId()}`)));for(const e of t)e.attemptDecryption(this,{isRetry:!0}).catch((t=>{this.logger.info(`Still unable to decrypt event ${e.getId()} after receiving key`)}))}}async onUserIdentityUpdated(e){const t=await this.getUserVerificationStatus(e.toString());this.emit(K.b.UserTrustStatusChanged,e.toString(),t),e.toString()===this.userId&&await this.checkKeyBackupAndEnable()}async handleSecretReceived(e,t){return this.logger.debug(`onReceiveSecret: Received secret ${e}`),"m.megolm_backup.v1"===e&&await this.backupManager.handleBackupSecretReceived(t)}async checkSecrets(e){const t=await this.olmMachine.getSecretsFromInbox(e);for(const i of t)if(await this.handleSecretReceived(e,i))break;await this.olmMachine.deleteSecretsFromInbox(e)}async onLiveEventFromSync(e){if(e.isState()||e.getUnsigned().transaction_id)return;const t=async t=>{Object(b.b)(e)&&await this.onKeyVerificationRequest(t)};if(e.isDecryptionFailure()||e.isEncrypted()){const i=setTimeout((()=>e.off(c.c.Decrypted,s)),3e5),s=(n,r)=>{r||(clearTimeout(i),e.off(c.c.Decrypted,s),t(n))};e.on(c.c.Decrypted,s)}else await t(e)}async onKeyVerificationRequest(e){const t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");if(this.logger.debug(`Incoming verification event ${e.getId()} type ${e.getType()} from ${e.getSender()}`),await this.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new a.RoomId(t)),e.getType()===R.b.RoomMessage&&e.getContent().msgtype===R.e.KeyVerificationRequest){const t=this.olmMachine.getVerificationRequest(new a.UserId(e.getSender()),e.getId());t?this.emit(K.b.VerificationRequestReceived,new b.a(t,this.outgoingRequestProcessor,this._supportedVerificationMethods)):this.logger.info(`Ignoring just-received verification request ${e.getId()} which did not start a rust-side verification`)}this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",e)}))}}class T{constructor(e,t,i){this.logger=e,this.olmMachine=t,this.crypto=i,n()(this,"eventsPendingKey",new l.b((()=>new l.b((()=>new Set)))))}async attemptEventDecryption(e){this.logger.info(`Attempting decryption of event ${e.getId()} in ${e.getRoomId()} from ${e.getSender()}`),this.addEventToPendingList(e);try{const t=await this.olmMachine.decryptRoomEvent(N(e),new a.RoomId(e.getRoomId()));return this.removeEventFromPendingList(e),{clearEvent:JSON.parse(t.event),claimedEd25519Key:t.senderClaimedEd25519Key,senderCurve25519Key:t.senderCurve25519Key,forwardingCurve25519KeyChain:t.forwardingCurve25519KeyChain}}catch(t){if(t instanceof a.MegolmDecryptionError){const i=e.getWireContent();let s;switch(t.code){case a.DecryptionErrorCode.MissingRoomKey:s=new O.b("MEGOLM_UNKNOWN_INBOUND_SESSION_ID","The sender's device has not sent us the keys for this message.",{session:i.sender_key+"|"+i.session_id}),this.crypto.startQueryKeyBackupRateLimited(e.getRoomId(),e.getWireContent().session_id);break;case a.DecryptionErrorCode.UnknownMessageIndex:s=new O.b("OLM_UNKNOWN_MESSAGE_INDEX","The sender's device has not sent us the keys for this message at this index.",{session:i.sender_key+"|"+i.session_id}),this.crypto.startQueryKeyBackupRateLimited(e.getRoomId(),e.getWireContent().session_id);break;default:s=new O.b("UNABLE_TO_DECRYPT",t.description,{session:i.sender_key+"|"+i.session_id})}throw s}throw new O.b("UNABLE_TO_DECRYPT","Unknown error")}}async getEncryptionInfoForEvent(e){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(null!==e.status)return{shieldColour:p.EventShieldColour.NONE,shieldReason:null};const t=await this.olmMachine.getRoomEventEncryptionInfo(N(e),new a.RoomId(e.getRoomId()));return function(e,t){if(void 0===t)return null;const i=t.shieldState(!1);let s,n;switch(i.color){case a.ShieldColor.Grey:s=p.EventShieldColour.GREY;break;case a.ShieldColor.None:s=p.EventShieldColour.NONE;break;default:s=p.EventShieldColour.RED}void 0===i.message?n=null:"Encrypted by an unverified user."===i.message?n=p.EventShieldReason.UNVERIFIED_IDENTITY:"Encrypted by a device not verified by its owner."===i.message?n=p.EventShieldReason.UNSIGNED_DEVICE:"The authenticity of this encrypted message can't be guaranteed on this device."===i.message?n=p.EventShieldReason.AUTHENTICITY_NOT_GUARANTEED:"Encrypted by an unknown or deleted device."===i.message?n=p.EventShieldReason.UNKNOWN_DEVICE:(e.warn(`Unknown shield state message '${i.message}'`),n=p.EventShieldReason.UNKNOWN);return{shieldColour:s,shieldReason:n}}(this.logger,t)}getEventsPendingRoomKey(e){const t=this.eventsPendingKey.get(e.senderKey.toBase64());if(!t)return[];const i=t.get(e.sessionId);if(!i)return[];const s=e.roomId.toString();return[...i].filter((e=>e.getRoomId()===s))}addEventToPendingList(e){const t=e.getWireContent(),i=t.sender_key,s=t.session_id;this.eventsPendingKey.getOrCreate(i).getOrCreate(s).add(e)}removeEventFromPendingList(e){const t=e.getWireContent(),i=t.sender_key,s=t.session_id,n=this.eventsPendingKey.get(i);if(!n)return;const r=n.get(s);r&&(r.delete(e),0===r.size&&(n.delete(s),0===n.size&&this.eventsPendingKey.delete(i)))}}function N(e){return JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()})}}).call(this,i(196).Buffer)},1539:function(e,t,i){"use strict";i.d(t,"a",(function(){return u}));var s=i(5),n=i.n(s),r=i(1391),o=i(9),a=i(3),c=i(241);class u{constructor(e,t,i,s,o){this.olmMachine=e,this.keyClaimManager=t,this.outgoingRequestManager=i,this.room=s,this.encryptionSettings=o,n()(this,"prefixedLogger",void 0),n()(this,"lazyLoadedMembersResolved",!1),this.prefixedLogger=a.a.getChild(`[${s.roomId} encryption]`);const c=s.getJoinedMembers();this.olmMachine.updateTrackedUsers(c.map((e=>new r.UserId(e.userId)))).then((()=>{this.prefixedLogger.debug(`Updated tracked users for room ${s.roomId}`)}))}onCryptoEvent(e){JSON.stringify(this.encryptionSettings)!=JSON.stringify(e)&&this.prefixedLogger.error("Ignoring m.room.encryption event which requests a change of config")}onRoomMembership(e){("join"==e.membership||"invite"==e.membership&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new r.UserId(e.userId)]).catch((e=>{this.prefixedLogger.error("Unable to update tracked users",e)}))}async ensureEncryptionSession(e){var t;if("m.megolm.v1.aes-sha2"!==this.encryptionSettings.algorithm)throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);const i=await this.room.getEncryptionTargetMembers();this.lazyLoadedMembersResolved||(await this.olmMachine.updateTrackedUsers(i.map((e=>new r.UserId(e.userId)))),this.lazyLoadedMembersResolved=!0,this.prefixedLogger.debug(`Updated tracked users for room ${this.room.roomId}`)),await this.outgoingRequestManager.doProcessOutgoingRequests(),this.prefixedLogger.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,i.map((e=>`${e.userId} (${e.membership})`)));const s=i.map((e=>new r.UserId(e.userId)));await this.keyClaimManager.ensureSessionsForUsers(s),this.prefixedLogger.debug("Sessions for users are ready; now sharing room key");const n=new r.EncryptionSettings;n.historyVisibility=function(e){switch(e){case c.b.Invited:return r.HistoryVisibility.Invited;case c.b.Joined:return r.HistoryVisibility.Joined;case c.b.Shared:return r.HistoryVisibility.Shared;case c.b.WorldReadable:return r.HistoryVisibility.WorldReadable}}(this.room.getHistoryVisibility()),n.algorithm=r.EncryptionAlgorithm.MegolmV1AesSha2,"number"==typeof this.encryptionSettings.rotation_period_ms&&(n.rotationPeriod=BigInt(1e3*this.encryptionSettings.rotation_period_ms)),"number"==typeof this.encryptionSettings.rotation_period_msgs&&(n.rotationPeriodMessages=BigInt(this.encryptionSettings.rotation_period_msgs)),n.onlyAllowTrustedDevices=null!==(t=this.room.getBlacklistUnverifiedDevices())&&void 0!==t?t:e;const o=await this.olmMachine.shareRoomKey(new r.RoomId(this.room.roomId),s,n);if(o)for(const e of o)await this.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(e)}async forceDiscardSession(){await this.olmMachine.invalidateGroupSession(new r.RoomId(this.room.roomId))&&this.prefixedLogger.info("Discarded existing group session")}async encryptEvent(e,t){await this.ensureEncryptionSession(t);const i=await this.olmMachine.encryptRoomEvent(new r.RoomId(this.room.roomId),e.getType(),JSON.stringify(e.getContent()));e.makeEncrypted(o.b.RoomMessageEncrypted,JSON.parse(i),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64())}}},1540:function(e,t,i){"use strict";i.d(t,"a",(function(){return g}));var s=i(5),n=i.n(s),r=i(1391),o=i(3),a=i(15),c=i(9);function u(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,s)}return i}class g{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e,t){let i;if(e instanceof r.KeysUploadRequest)i=await this.rawJsonRequest(a.i.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof r.KeysQueryRequest)i=await this.rawJsonRequest(a.i.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof r.KeysClaimRequest)i=await this.rawJsonRequest(a.i.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof r.SignatureUploadRequest)i=await this.rawJsonRequest(a.i.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof r.KeysBackupRequest)i=await this.rawJsonRequest(a.i.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof r.ToDeviceRequest)i=await this.sendToDeviceRequest(e);else if(e instanceof r.RoomMessageRequest){const t=`/_matrix/client/v3/rooms/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;i=await this.rawJsonRequest(a.i.Put,t,{},e.body)}else{if(e instanceof r.SigningKeysUploadRequest)return void await this.makeRequestWithUIA(a.i.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,t);o.a.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),i=""}if(e.id)try{await this.olmMachine.markRequestAsSent(e.id,e.type,i)}catch(e){if(!(e instanceof Error)||"Attempt to use a moved value"!==e.message&&"null pointer passed to rust"!==e.message)throw e;o.a.log(`Ignoring error '${e.message}': client is likely shutting down`)}}async sendToDeviceRequest(e){const t=JSON.parse(e.body),i=[];for(const[e,s]of Object.entries(t.messages))for(const[t,n]of Object.entries(s))i.push(`${e}/${t} (msgid ${n[c.k]})`);o.a.info(`Sending batch of to-device messages. type=${e.event_type} txnid=${e.txn_id}`,i);const s=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);return await this.rawJsonRequest(a.i.Put,s,{},e.body)}async makeRequestWithUIA(e,t,i,s,r){if(!r)return await this.rawJsonRequest(e,t,i,s);const o=JSON.parse(s),a=await r((async s=>{const r=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?u(Object(i),!0).forEach((function(t){n()(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):u(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},o);null!==s&&(r.auth=s);const a=await this.rawJsonRequest(e,t,i,JSON.stringify(r));return JSON.parse(a)}));return JSON.stringify(a)}async rawJsonRequest(e,t,i,s){return await this.http.authedRequest(e,t,i,s,{json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""})}}},1541:function(e,t,i){"use strict";i.d(t,"a",(function(){return r}));var s=i(5),n=i.n(s);class r{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,n()(this,"currentClaimPromise",void 0),n()(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e){const t=this.currentClaimPromise.catch((()=>{})).then((()=>this.ensureSessionsForUsersInner(e)));return this.currentClaimPromise=t,t}async ensureSessionsForUsersInner(e){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");const t=await this.olmMachine.getMissingSessions(e);t&&await this.outgoingRequestProcessor.makeOutgoingRequest(t)}}},1542:function(e,t,i){"use strict";i.d(t,"b",(function(){return r})),i.d(t,"a",(function(){return o}));var s=i(1391),n=i(209);function r(e,t){const i=new Map;for(const[t,s]of e.keys.entries())i.set(t.toString(),s.toBase64());let r=n.b.Unverified;e.isBlacklisted()?r=n.b.Blocked:e.isVerified()&&(r=n.b.Verified);const o=new Map,a=e.signatures.get(t);if(a){const e=new Map;for(const[t,i]of a.entries())i.isValid()&&i.signature&&e.set(t,i.signature.toBase64());o.set(t.toString(),e)}const c=e.algorithms,u=new Set;return c.forEach((e=>{switch(e){case s.EncryptionAlgorithm.MegolmV1AesSha2:u.add("m.megolm.v1.aes-sha2");break;case s.EncryptionAlgorithm.OlmV1Curve25519AesSha2:default:u.add("m.olm.v1.curve25519-aes-sha2")}})),new n.a({deviceId:e.deviceId.toString(),userId:t.toString(),keys:i,algorithms:Array.from(u),verified:r,signatures:o,displayName:e.displayName})}function o(e){return new Map(Object.entries(e).map((([e,t])=>[e,a(t)])))}function a(e){var t;const i=new Map(Object.entries(e.keys)),s=null===(t=e.unsigned)||void 0===t?void 0:t.device_display_name,r=new Map;if(e.signatures)for(const t in e.signatures)r.set(t,new Map(Object.entries(e.signatures[t])));return new n.a({deviceId:e.device_id,userId:e.user_id,keys:i,algorithms:e.algorithms,verified:n.b.Unverified,signatures:r,displayName:s})}},1543:function(e,t,i){"use strict";i.d(t,"a",(function(){return n}));var s=i(3);class n{constructor(e,t,i){this.olmMachine=e,this.outgoingRequestProcessor=t,this.secretStorage=i}async bootstrapCrossSigning(e){if(e.setupNewCrossSigning)return void await this.resetCrossSigning(e.authUploadDeviceSigningKeys);const t=await this.olmMachine.crossSigningStatus(),i=await this.secretStorage.get("m.cross_signing.master"),n=await this.secretStorage.get("m.cross_signing.self_signing"),r=await this.secretStorage.get("m.cross_signing.user_signing"),o=Boolean(i&&n&&r),a=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(s.a.log("bootStrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:o}),a)o?s.a.log("bootStrapCrossSigning: Olm device has private keys and they are saved in 4S, do nothing"):(s.a.log("bootStrapCrossSigning: Olm device has private keys: exporting to secret storage"),await this.exportCrossSigningKeysToStorage());else if(o){s.a.log("bootStrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"),await this.olmMachine.importCrossSigningKeys(i,n,r);const e=await this.olmMachine.getDevice(this.olmMachine.userId,this.olmMachine.deviceId),t=await e.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(t)}else s.a.log("bootStrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),await this.resetCrossSigning(e.authUploadDeviceSigningKeys);s.a.log("bootStrapCrossSigning: complete")}async resetCrossSigning(e){const t=await this.olmMachine.bootstrapCrossSigning(!0);await this.secretStorage.hasKey()&&await this.exportCrossSigningKeysToStorage(),s.a.log("bootStrapCrossSigning: publishing keys to server");for(const i of t)await this.outgoingRequestProcessor.makeOutgoingRequest(i,e)}async exportCrossSigningKeysToStorage(){const e=await this.olmMachine.exportCrossSigningKeys();null!=e&&e.masterKey?this.secretStorage.store("m.cross_signing.master",e.masterKey):s.a.error("Cannot export MSK to secret storage, private key unknown"),null!=e&&e.self_signing_key?this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key):s.a.error("Cannot export SSK to secret storage, private key unknown"),null!=e&&e.userSigningKey?this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey):s.a.error("Cannot export USK to secret storage, private key unknown")}}},1544:function(e,t,i){"use strict";async function s(e){return n(e,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}async function n(e,t){const i=await e.getDefaultKeyId();if(!i)return!1;for(const s of t){if(!(i in(await e.isStored(s)||{})))return!1}return!0}i.d(t,"b",(function(){return s})),i.d(t,"a",(function(){return n}))},1545:function(e,t,i){"use strict";(function(e){i.d(t,"a",(function(){return g})),i.d(t,"c",(function(){return y})),i.d(t,"b",(function(){return m}));var s=i(5),n=i.n(s),r=i(1391),o=i(92),a=i(51),c=i(169),u=i(9);class g extends a.b{constructor(e,t,i){super(),this.inner=e,this.outgoingRequestProcessor=t,this.supportedVerificationMethods=i,n()(this,"reEmitter",void 0),n()(this,"_accepting",!1),n()(this,"_cancelling",!1),n()(this,"_verifier",void 0),this.reEmitter=new c.b(this);e.registerChangesCallback((async()=>{const e=this.inner.getVerification();e instanceof r.Sas?(void 0===this._verifier||this._verifier instanceof d)&&this.setVerifier(new l(e,this,t)):e instanceof r.Qr&&void 0===this._verifier&&this.setVerifier(new d(e,t)),this.emit(o.b.Change)}))}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[o.b.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[o.b.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return null===(e=this.inner.roomId)||void 0===e?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return null===(e=this.inner.otherDeviceId)||void 0===e?void 0:e.toString()}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){const e=this.inner.phase();switch(e){case r.VerificationRequestPhase.Created:case r.VerificationRequestPhase.Requested:return o.a.Requested;case r.VerificationRequestPhase.Ready:return this._accepting?o.a.Requested:o.a.Ready;case r.VerificationRequestPhase.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case r.VerificationRequestPhase.Done:return o.a.Done;case r.VerificationRequestPhase.Cancelled:return o.a.Cancelled}throw new Error(`Unknown verification phase ${e}`)}get pending(){if(this.inner.isPassive())return!1;const e=this.phase;return e!==o.a.Done&&e!==o.a.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==o.a.Started)return null;const e=this.inner.getVerification();return e instanceof r.Sas?"m.sas.v1":e instanceof r.Qr?"m.reciprocate.v1":null}otherPartySupportsMethod(e){const t=this.inner.theirSupportedMethods;if(void 0===t)return!1;const i=p[e];return t.some((e=>e===i))}async accept(){if(this.inner.phase()!==r.VerificationRequestPhase.Requested||this._accepting)throw new Error(`Cannot accept a verification request in phase ${this.phase}`);this._accepting=!0;try{const e=this.inner.acceptWithMethods(this.supportedVerificationMethods.map(y));e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._accepting=!1}this.emit(o.b.Change)}async cancel(e){if(!this._cancelling){this._cancelling=!0;try{const e=this.inner.cancel();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._cancelling=!1}}}beginKeyVerification(e,t){throw new Error("not implemented")}async startVerification(e){if("m.sas.v1"!==e)throw new Error(`Unsupported verification method ${e}`);const t=await this.inner.startSas();if(t){const[,e]=t;await this.outgoingRequestProcessor.makeOutgoingRequest(e)}if(!this._verifier)throw new Error("Still no verifier after startSas() call");return this._verifier}async scanQRCode(e){const t=r.QrCodeScan.fromBytes(new Uint8ClampedArray(e)),i=await this.inner.scanQrCode(t);if(!this._verifier)throw new Error("Still no verifier after scanQrCode() call");const s=i.reciprocate();return s&&await this.outgoingRequestProcessor.makeOutgoingRequest(s),this._verifier}get verifier(){return this.phase===o.a.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}async generateQRCode(){const t=await this.inner.generateQrCode();if(t)return e.from(t.toBytes())}get cancellationCode(){throw new Error("not implemented")}get cancellingUserId(){throw new Error("not implemented")}}class h extends a.b{constructor(e,t){super(),this.inner=e,this.outgoingRequestProcessor=t,n()(this,"completionPromise",void 0),this.completionPromise=new Promise(((t,i)=>{e.registerChangesCallback((async()=>{if(this.onChange(),this.inner.isDone())t(void 0);else if(this.inner.isCancelled()){const e=this.inner.cancelInfo();i(new Error(`Verification cancelled by ${e.cancelledbyUs()?"us":"them"} with code ${e.cancelCode()}: ${e.reason()}`))}this.emit(o.b.Change)}))})),this.completionPromise.catch((()=>null))}onChange(){}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){const t=this.inner.cancel();t&&this.outgoingRequestProcessor.makeOutgoingRequest(t)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class d extends h{constructor(e,t){super(e,t),n()(this,"callbacks",null)}onChange(){null===this.callbacks&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>this.confirmScanning(),cancel:()=>this.cancel()})}async verify(){null!==this.callbacks&&this.emit(o.c.ShowReciprocateQr,this.callbacks),await this.completionPromise}get verificationPhase(){switch(this.inner.state()){case r.QrState.Created:return o.a.Ready;case r.QrState.Scanned:case r.QrState.Confirmed:case r.QrState.Reciprocated:return o.a.Started;case r.QrState.Done:return o.a.Done;case r.QrState.Cancelled:return o.a.Cancelled;default:throw new Error(`Unknown qr code state ${this.inner.state()}`)}}getReciprocateQrCodeCallbacks(){return this.callbacks}async confirmScanning(){const e=this.inner.confirmScanning();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}}class l extends h{constructor(e,t,i){super(e,i),n()(this,"callbacks",null)}async verify(){const e=this.inner.accept();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e),await this.completionPromise}onChange(){if(null===this.callbacks){const e=this.inner.emoji(),t=this.inner.decimals();if(void 0===e&&void 0===t)return;this.callbacks={sas:{decimal:t,emoji:null==e?void 0:e.map((e=>[e.symbol,e.description]))},confirm:async()=>{const e=await this.inner.confirm();for(const t of e)await this.outgoingRequestProcessor.makeOutgoingRequest(t)},mismatch:()=>{throw new Error("impl")},cancel:()=>{throw new Error("impl")}},this.emit(o.c.ShowSas,this.callbacks)}}get verificationPhase(){return o.a.Started}getShowSasCallbacks(){return this.callbacks}}const p={"m.sas.v1":r.VerificationMethod.SasV1,"m.qr_code.scan.v1":r.VerificationMethod.QrCodeScanV1,"m.qr_code.show.v1":r.VerificationMethod.QrCodeShowV1,"m.reciprocate.v1":r.VerificationMethod.ReciprocateV1};function y(e){const t=p[e];if(void 0===t)throw new Error(`Unknown verification method ${e}`);return t}function m(e){switch(e.getType()){case u.b.KeyVerificationCancel:case u.b.KeyVerificationDone:case u.b.KeyVerificationMac:case u.b.KeyVerificationStart:case u.b.KeyVerificationKey:case u.b.KeyVerificationReady:case u.b.KeyVerificationAccept:return!0;case u.b.RoomMessage:return e.getContent().msgtype===u.e.KeyVerificationRequest;default:return!1}}}).call(this,i(196).Buffer)},1546:function(e,t,i){"use strict";i.d(t,"b",(function(){return h})),i.d(t,"a",(function(){return l}));var s=i(5),n=i.n(s),r=i(1391),o=i(3),a=i(15),c=i(45),u=i(51),g=i(7);class h extends u.b{constructor(e,t,i){super(),this.olmMachine=e,this.http=t,this.outgoingRequestProcessor=i,n()(this,"checkedForBackup",!1),n()(this,"activeBackupVersion",null),n()(this,"stopped",!1),n()(this,"backupKeysLoopRunning",!1),n()(this,"keyBackupCheckInProgress",null)}stop(){this.stopped=!0}async getActiveBackupVersion(){return await this.olmMachine.isBackupEnabled()?this.activeBackupVersion:null}async isKeyBackupTrusted(e){const t=await this.olmMachine.verifyBackup(e),i=await this.olmMachine.getBackupKeys(),s=null==i?void 0:i.decryptionKey;return{matchesDecryptionKey:!!s&&d(e,s),trusted:t.trusted()}}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally((()=>{this.keyBackupCheckInProgress=null}))),this.keyBackupCheckInProgress)}async handleBackupSecretReceived(e){var t;const i=await this.checkKeyBackupAndEnable(!0);if(null==i||null===(t=i.backupInfo)||void 0===t||!t.version||!i.trustInfo.trusted)return o.a.warn("Received backup decryption key, but there is no trusted server-side key backup"),!1;try{const t=r.BackupDecryptionKey.fromBase64(e);return d(i.backupInfo,t)?(o.a.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),await this.olmMachine.saveBackupDecryptionKey(t,i.backupInfo.version),!0):(o.a.debug("onReceiveSecret: backup decryption key does not match current backup version"),!1)}catch(e){o.a.warn("handleBackupSecretReceived: Invalid backup decryption key",e)}return!1}async doCheckKeyBackup(){o.a.log("Checking key backup status...");let e=null;try{e=await this.requestKeyBackupVersion()}catch(e){return o.a.warn("Error checking for active key backup",e),null}this.checkedForBackup=!0,e&&!e.version&&o.a.warn("active backup lacks a useful 'version'; ignoring it");const t=await this.getActiveBackupVersion();if(!e)return null!==t?(o.a.log("No key backup present on server: disabling key backup"),await this.disableKeyBackup()):o.a.log("No key backup present on server: not enabling key backup"),null;const i=await this.isKeyBackupTrusted(e);return i.trusted?null===t?(o.a.log(`Found usable key backup v${e.version}: enabling key backups`),await this.enableKeyBackup(e)):t!==e.version?(o.a.log(`On backup version ${t} but found version ${e.version}: switching.`),await this.disableKeyBackup(),await this.enableKeyBackup(e)):o.a.log(`Backup version ${e.version} still current`):null!==t?(o.a.log("Key backup present on server but not trusted: disabling key backup"),await this.disableKeyBackup()):o.a.log("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:e,trustInfo:i}}async enableKeyBackup(e){await this.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),this.activeBackupVersion=e.version,this.emit(c.b.KeyBackupStatus,!0),this.backupKeysLoop()}async maybeUploadKey(){null!=this.activeBackupVersion&&this.backupKeysLoop()}async disableKeyBackup(){await this.olmMachine.disableBackup(),this.activeBackupVersion=null,this.emit(c.b.KeyBackupStatus,!1)}async backupKeysLoop(e=1e4){if(this.backupKeysLoopRunning)return void o.a.log("Backup loop already running");this.backupKeysLoopRunning=!0,o.a.log(`Starting loop for ${this.activeBackupVersion}.`);const t=Math.random()*e;await Object(g.N)(t);try{let e=0;for(;!this.stopped;){const t=await this.olmMachine.backupRoomKeys();if(!t||this.stopped||!this.activeBackupVersion)return void o.a.log(`Ending loop for ${this.activeBackupVersion}.`);try{await this.outgoingRequestProcessor.makeOutgoingRequest(t),e=0;const i=await this.olmMachine.roomKeyCounts(),s=i.total-i.backedUp;this.emit(c.b.KeyBackupSessionsRemaining,s)}catch(t){if(e++,o.a.error("Error processing backup request for rust crypto-sdk",t),t instanceof a.f){const e=t.data.errcode;if("M_NOT_FOUND"==e||"M_WRONG_ROOM_KEYS_VERSION"==e)return await this.disableKeyBackup(),this.emit(c.b.KeyBackupFailed,t.data.errcode),this.backupKeysLoopRunning=!1,void this.checkKeyBackupAndEnable(!0);if("M_LIMIT_EXCEEDED"==e){const e=t.data.retry_after_ms;if(e>0){Object(g.N)(e);continue}}}await Object(g.N)(1e3*Math.pow(2,Math.min(e-1,4)))}}}finally{this.backupKeysLoopRunning=!1}}async requestKeyBackupVersion(){try{return await this.http.authedRequest(a.i.Get,"/room_keys/version",void 0,void 0,{prefix:a.a.V3})}catch(e){if("M_NOT_FOUND"===e.errcode)return null;throw e}}async setupKeyBackup(e){await this.deleteAllKeyBackupVersions();const t=r.BackupDecryptionKey.createRandomKey(),i=t.megolmV1PublicKey,s={public_key:i.publicKeyBase64};await e(s);const n=await this.http.authedRequest(a.i.Post,"/room_keys/version",void 0,{algorithm:i.algorithm,auth_data:s},{prefix:a.a.V3});return this.olmMachine.saveBackupDecryptionKey(t,n.version),{version:n.version,algorithm:i.algorithm,authData:s,decryptionKey:t}}async deleteAllKeyBackupVersions(){var e,t;let i=null!==(e=null===(t=await this.requestKeyBackupVersion())||void 0===t?void 0:t.version)&&void 0!==e?e:null;for(;null!=i;){var s,n;await this.deleteKeyBackupVersion(i),i=null!==(s=null===(n=await this.requestKeyBackupVersion())||void 0===n?void 0:n.version)&&void 0!==s?s:null}}async deleteKeyBackupVersion(e){o.a.debug(`deleteKeyBackupVersion v:${e}`);const t=Object(g.o)("/room_keys/version/$version",{$version:e});await this.http.authedRequest(a.i.Delete,t,void 0,void 0,{prefix:a.a.V3})}}function d(e,t){var i;return"m.megolm_backup.v1.curve25519-aes-sha2"!==e.algorithm?(o.a.warn("backupMatchesPrivateKey: Unsupported backup algorithm",e.algorithm),!1):(null===(i=e.auth_data)||void 0===i?void 0:i.public_key)===t.megolmV1PublicKey.publicKeyBase64}class l{constructor(e){n()(this,"decryptionKey",void 0),n()(this,"sourceTrusted",void 0),this.decryptionKey=e,this.sourceTrusted=!1}async decryptSessions(e){const t=[];for(const[i,s]of Object.entries(e))try{const e=JSON.parse(this.decryptionKey.decryptV1(s.session_data.ephemeral,s.session_data.mac,s.session_data.ciphertext));e.session_id=i,t.push(e),await Object(g.s)()}catch(e){o.a.log("Failed to decrypt megolm session from backup",e,s)}return t}free(){this.decryptionKey.free()}}},1547:function(e,t,i){"use strict";i.d(t,"a",(function(){return o}));var s=i(5),n=i.n(s),r=i(7);class o{constructor(e,t,i){this.logger=e,this.olmMachine=t,this.outgoingRequestProcessor=i,n()(this,"stopped",!1),n()(this,"outgoingRequestLoopRunning",!1),n()(this,"nextLoopDeferred",void 0)}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=Object(r.m)());const e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch((e=>{this.logger.error("Uncaught error in outgoing request loop",e)})),e}async outgoingRequestLoop(){if(this.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped&&this.nextLoopDeferred;){const e=this.nextLoopDeferred;this.nextLoopDeferred=void 0,await this.processOutgoingRequests().then(e.resolve,e.reject)}}finally{this.outgoingRequestLoopRunning=!1}this.nextLoopDeferred&&this.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))}async processOutgoingRequests(){if(this.stopped)return;const e=await this.olmMachine.outgoingRequests();for(const t of e){if(this.stopped)return;try{await this.outgoingRequestProcessor.makeOutgoingRequest(t)}catch(e){this.logger.error(`Failed to process outgoing request ${t.type}: ${e}`)}}}}}}]);
//# sourceMappingURL=34.js.map